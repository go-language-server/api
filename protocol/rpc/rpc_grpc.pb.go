// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package rpc

import (
	context "context"

	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	anypb "google.golang.org/protobuf/types/known/anypb"
	emptypb "google.golang.org/protobuf/types/known/emptypb"

	protocol "go.lsp.dev/api/protocol"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion7

// LanguageServerProtocolClient is the client API for LanguageServerProtocol service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type LanguageServerProtocolClient interface {
	// Cancel notification is the base protocol offers support for request cancellation. To cancel a
	// request, a CancelRequest notification message is sent.
	//
	// A request that got canceled still needs to return from the server and send a response back. It
	// can not be left open / hanging. This is in line with the JSON RPC protocol that requires that
	// every request sends a response back. In addition it allows for returning partial results on
	// cancel. If the request returns an error response on cancellation it is advised to set the error
	// code to [Codes.RequestCancelled][protocol.Codes].
	Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Progress notification is the base protocol offers also support to report progress in a generic
	// fashion. This mechanism can be used to report any kind of progress including work done progress
	// (usually used to report progress in the user interface using a progress bar) and partial result
	// progress to support streaming of results.
	//
	// Progress is reported against a token. The token is different than the request ID which allows
	// to report progress out of band and also for notification.
	//
	// @since 3.15.0
	Progress(ctx context.Context, in *ProgressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Initialize request is sent as the first request from the client to the server. If the server
	// receives a request or notification before the initialize request it should act as follows:
	//
	// - For a request the response should be an error with `code: -32002`. The message can be picked
	// by the server.
	// - Notifications should be dropped, except for the exit notification. This will allow the exit
	// of a server without an initialize request.
	//
	// Until the server has responded to the `initialize` request with an `InitializeResponse`, the
	// client must not send any additional requests or notifications to the server. In addition the
	// server is not allowed to send any requests or notifications to the client until it has
	// responded with an `InitializeResponse`, with the exception that during the initialize request
	// the server is allowed to send the notifications `window/showMessage`, `window/logMessage` and
	// `telemetry/event` as well as the `window/showMessageRequest` request to the client. In case the
	// client sets up a progress token in the initialize params (e.g. property `workDoneToken`) the
	// server is also allowed to use that token (and only that token) using the `$/progress`
	// notification sent from the server to the client.
	//
	// The initialize request may only be sent once.
	Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error)
	// Initialized notification is sent from the client to the server after the client received the
	// result of the `initialize` request but before the client is sending any other request or
	// notification to the server.
	//
	// The server can use the `initialized` notification for example to dynamically register
	// capabilities.
	//
	// The `initialized` notification may only be sent once.
	Initialized(ctx context.Context, in *InitializedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Shutdown request is sent from the client to the server.
	//
	// It asks the server to shut down, but to not exit (otherwise the response might not be delivered
	// correctly to the client). There is a separate exit notification that asks the server to exit.
	//
	// Clients must not send any notifications other than exit or requests to a server to which they
	// have sent a shutdown request.
	//
	// If a server receives requests after a shutdown request those requests should error with
	// `InvalidRequest`.
	Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*protocol.Error, error)
	// Exit notification to ask the server to exit its process.
	//
	// The server should exit with `success` code 0 if the shutdown request has been received before;
	// otherwise with `error` code 1.
	Exit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// LogTrace notification to log the trace of the server’s execution.
	//
	// The amount and content of these notifications depends on the current `trace` configuration.
	// If `trace` is `'off'`, the server should not send any `logTrace` notification. If `trace` is
	// `'message'`, the server should not add the `'verbose'` field in the logTraceRequest.
	//
	// `$/logTrace` should be used for systematic trace reporting. For single debugging messages, the
	// server should send window/logMessage notifications.
	LogTrace(ctx context.Context, in *LogTraceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// SetTrace notification that should be used by the client to modify the trace setting of the
	// server.
	//
	// (-- api-linter: core::0134::synonyms=disabled
	//     api-linter: core::0136::http-method=disabled --)
	SetTrace(ctx context.Context, in *SetTraceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ShowMessage notification is the show message notification is sent from a server to a client to
	// ask the client to display a particular message in the user interface.
	ShowMessage(ctx context.Context, in *ShowMessageRequestParams, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// ShowMessageRequest request is the show message request is sent from a server to a client to ask
	// the client to display a particular message in the user interface. In addition to the show
	// message notification the request allows to pass actions and to wait for an answer from the
	// client.
	ShowMessageRequest(ctx context.Context, in *ShowMessageRequestRequest, opts ...grpc.CallOption) (*ShowMessageResponse, error)
	// LogMessage notification is the log message notification is sent from the server to the client
	// to ask the client to log a particular message.
	LogMessage(ctx context.Context, in *LogMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// CreateWorkDoneProgress is the `window/workDoneProgress/create` request is sent from the server
	// to the client to ask the client to create a work done progress.
	//
	// (-- api-linter: core::0133::http-uri-parent=disabled
	//     api-linter: core::0133::http-body=disabled
	//     api-linter: core::0133::request-message-name=disabled
	//     api-linter: core::0133::response-message-name=disabled --)
	CreateWorkDoneProgress(ctx context.Context, in *WorkDoneProgressCreateRequest, opts ...grpc.CallOption) (*protocol.Error, error)
	// CancelWorkDoneProgress is the `window/workDoneProgress/cancel` notification is sent from the
	// client to the server to cancel a progress initiated on the server side using the
	// `window/workDoneProgress/create`.
	CancelWorkDoneProgress(ctx context.Context, in *WorkDoneProgressCancelRequest, opts ...grpc.CallOption) (*protocol.Error, error)
	// Telemetry notification is the telemetry notification is sent from the server to the client to
	// ask the client to log a telemetry event.
	Telemetry(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// WorkspaceFolders request is the workspace/workspaceFolders request is sent from the server to
	// the client to fetch the current open list of workspace folders.
	//
	// Returns null in the response if only a single file is open in the tool. Returns an empty array
	// if a workspace is open but no folders are configured.
	//
	// @since 3.6.0
	WorkspaceFolders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkspaceFoldersResponse, error)
	// DidChangeWorkspaceFolders notification is the `workspace/didChangeWorkspaceFolders`
	// notification is sent from the client to the server to inform the server about workspace folder
	// configuration changes.
	//
	// The notification is sent by default if both client capability `workspace.workspaceFolders` and
	// the server capability `workspace.workspaceFolders.supported` are true; or if the server has
	// registered itself to receive this notification. To register for the
	// `workspace/didChangeWorkspaceFolders` send a client/registerCapability request from the server
	// to the client. The `registration` parameter must have a registrations item of the following
	// form, where id is a unique id used to unregister the capability (the example uses a UUID):
	//
	// @since 3.6.0
	DidChangeWorkspaceFolders(ctx context.Context, in *DidChangeWorkspaceFoldersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DidChangeConfiguration a notification sent from the client to the server to signal the change
	// of configuration settings.
	DidChangeConfiguration(ctx context.Context, in *DidChangeConfigurationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Configuration request is the `workspace/configuration` request is sent from the server to the
	// client to fetch configuration settings from the client.
	//
	// The request can fetch several configuration settings in one roundtrip. The order of the
	// returned configuration settings correspond to the order of the passed `ConfigurationItems`
	// (e.g. the first item in the response is the result for the first configuration item in the
	// params).
	//
	// @since 3.6.0
	Configuration(ctx context.Context, in *ConfigurationRequest, opts ...grpc.CallOption) (*ConfigurationResponse, error)
	// DidChangeWatchedFiles notification is the watched files notification is sent from the client to
	// the server when the client detects changes to files watched by the language client.
	//
	// It is recommended that servers register for these file events using the registration mechanism.
	// In former implementations clients pushed file events without the server actively asking for it.
	DidChangeWatchedFiles(ctx context.Context, in *DidChangeWatchedFilesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// WorkspaceSymbols request is the workspace symbol request is sent from the client to the server
	// to list project-wide symbols matching the query string.
	//
	// (-- api-linter: core::0136::http-uri-suffix=disabled --)
	WorkspaceSymbols(ctx context.Context, in *ConfigurationRequest, opts ...grpc.CallOption) (*WorkspaceSymbolsResponse, error)
	// ExecuteCommand is the `workspace/executeCommand` request is sent from the client to the server
	// to trigger command execution on the server.
	//
	// In most cases the server creates a `WorkspaceEdit` structure and applies the changes to the
	// workspace using the request `workspace/applyEdit` which is sent from the server to the client.
	ExecuteCommand(ctx context.Context, in *ExecuteCommandParams, opts ...grpc.CallOption) (*ExecuteCommandResponse, error)
	// ApplyEdit request is sent from the server to the client to modify resource on the client side.
	ApplyEdit(ctx context.Context, in *ApplyWorkspaceEditRequest, opts ...grpc.CallOption) (*ApplyWorkspaceEditResponse, error)
	// DidOpenTextDocument notification is the `DidOpenTextDocumentRequest` contain the language id
	// the document is associated with.
	//
	// If the language Id of a document changes, the client needs to send a `textDocument/didClose` to
	// the server followed by a `textDocument/didOpen` with the new language id if the server handles
	// the new language id as well.
	DidOpenTextDocument(ctx context.Context, in *DidOpenTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DidChangeTextDocument notification is the document change notification is sent from the client
	// to the server to signal changes to a text document.
	//
	// Before a client can change a text document it must claim ownership of its content using the
	// textDocument/didOpen notification.
	//
	// In 2.0 the shape of the params has changed to include proper version numbers and language ids.
	DidChangeTextDocument(ctx context.Context, in *DidChangeTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// WillSaveTextDocument notification is the document will save notification is sent from the
	// client to the server before the document is actually saved.
	WillSaveTextDocument(ctx context.Context, in *WillSaveTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// WillSaveWaitUntilTextDocument request is the document will save request is sent from the client
	// to the server before the document is actually saved.
	//
	// The request can return an array of TextEdits which will be applied to the text document before
	// it is saved.
	//
	// Please note that clients might drop results if computing the text edits took too long or if a
	// server constantly fails on this request. This is done to keep the save fast and reliable.
	WillSaveWaitUntilTextDocument(ctx context.Context, in *WillSaveTextDocumentRequest, opts ...grpc.CallOption) (*WillSaveTextDocumentResponse, error)
	// DidSaveTextDocument notification is the document save notification is sent from the client to
	// the server when the document was saved in the client.
	DidSaveTextDocument(ctx context.Context, in *DidSaveTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// DidCloseTextDocument notification is the document close notification is sent from the client to
	// the server when the document got closed in the client.
	//
	// The document’s master now exists where the document’s Uri points to (e.g. if the document’s Uri
	// is a file Uri the master now exists on disk). As with the open notification the close
	// notification is about managing the document’s content.
	//
	// Receiving a close notification doesn’t mean that the document was open in an editor before. A
	// close notification requires a previous open notification to be sent. Note that a server’s
	// ability to fulfill requests is independent of whether a text document is open or closed.
	DidCloseTextDocument(ctx context.Context, in *DidCloseTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// PublishDiagnostics notification is the diagnostics notification are sent from the server to the
	// client to signal results of validation runs.
	PublishDiagnostics(ctx context.Context, in *PublishDiagnosticsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error)
	// Completion request is the Completion request is sent from the client to the server to compute
	// completion items at a given cursor position.
	//
	// Completion items are presented in the IntelliSense user interface. If computing full completion
	// items is expensive, servers can additionally provide a handler for the completion item resolve
	// request (‘completionItem/resolve’).
	//
	// This request is sent when a completion item is selected in the user interface. A typical use
	// case is for example: the `textDocument/completion` request doesn’t fill in the documentation
	// property for returned completion items since it is expensive to compute. When the item is
	// selected in the user interface then a `completionItem/resolve` request is sent with the
	// selected completion item as a parameter.
	//
	// The returned completion item should have the documentation property filled in. The request can
	// only delay the computation of the `detail` and `documentation` properties. Other properties
	// like `sortText`, `filterText`, `insertText`, `textEdit` and `additionalTextEdits` must be
	// provided in the `textDocument/completion` response and must not be changed during resolve.
	Completion(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error)
	// CompletionItemResolve request is the request is sent from the client to the server to resolve
	// additional information for a given completion item.
	CompletionItemResolve(ctx context.Context, in *CompletionItemResolveRequest, opts ...grpc.CallOption) (*CompletionItemResolveResponse, error)
	// Hover Request is the hover request is sent from the client to the server to request hover
	// information at a given text document position.
	Hover(ctx context.Context, in *HoverRequest, opts ...grpc.CallOption) (*HoverResponse, error)
	// SignatureHelp request is the signature help request is sent from the client to the server to
	// request signature information at a given cursor position.
	SignatureHelp(ctx context.Context, in *SignatureHelpRequest, opts ...grpc.CallOption) (*SignatureHelpResponse, error)
	// GotoDeclaration request is the go to declaration request is sent from the client to the server
	// to resolve the declaration location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.declaration.linkSupport`.
	//
	// @since 3.14.0
	GotoDeclaration(ctx context.Context, in *DeclarationRequest, opts ...grpc.CallOption) (*DeclarationResponse, error)
	// GotoDefinition request is the go to definition request is sent from the client to the server to
	// resolve the definition location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.definition.linkSupport`.
	GotoDefinition(ctx context.Context, in *DefinitionRequest, opts ...grpc.CallOption) (*DefinitionResponse, error)
	// GotoTypeDefinition request is the go to type definition request is sent from the client to the
	// server to resolve the type definition location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.typeDefinition.linkSupport`.
	//
	// @since 3.6.0
	GotoTypeDefinition(ctx context.Context, in *TypeDefinitionRequest, opts ...grpc.CallOption) (*TypeDefinitionResponse, error)
	// GotoImplementation request is the go to implementation request is sent from the client to the
	// server to resolve the implementation location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.implementation.linkSupport`.
	//
	// @since 3.6.0
	GotoImplementation(ctx context.Context, in *ImplementationRequest, opts ...grpc.CallOption) (*ImplementationResponse, error)
	// FindReferences request is the references request is sent from the client to the server to
	// resolve project-wide references for the symbol denoted by the given text document position.
	FindReferences(ctx context.Context, in *ReferenceRequest, opts ...grpc.CallOption) (*ReferenceResponse, error)
	// DocumentHighlights request is the document highlight request is sent from the client to the
	// server to resolve a document highlights for a given text document position.
	//
	// For programming languages this usually highlights all references to the symbol scoped to this
	// file. However we kept `textDocument/documentHighlight` and `textDocument/references` separate
	// requests since the first one is allowed to be more fuzzy.
	//
	// Symbol matches usually have a DocumentHighlightKind of `Read` or `Write` whereas fuzzy or
	// textual matches use `Text` as the kind.
	DocumentHighlights(ctx context.Context, in *DocumentHighlightRequest, opts ...grpc.CallOption) (*DocumentHighlightsResponse, error)
	// DocumentSymbols request is the document symbol request is sent from the client to the server.
	//
	// The returned result is either
	//
	// - SymbolInformation[] which is a flat list of all symbols found in a given text document. Then
	// neither the symbol’s location range nor the symbol’s container name should be used to infer a
	// hierarchy.
	//
	// - DocumentSymbol[] which is a hierarchy of symbols found in a given text document.
	DocumentSymbols(ctx context.Context, in *DocumentSymbolRequest, opts ...grpc.CallOption) (*DocumentSymbolResponse, error)
	// CodeAction request is the code action request is sent from the client to the server to compute
	// commands for a given text document and range.
	//
	// These commands are typically code fixes to either fix problems or to beautify/refactor code.
	//
	// The result of a `textDocument/codeAction` request is an array of `Command` literals which are
	// typically presented in the user interface. To ensure that a server is useful in many clients
	// the commands specified in a code actions should be handled by the server and not by the client
	// (see `workspace/executeCommand` and `ServerCapabilities.executeCommandProvider`). If the client
	// supports providing edits with a code action then the mode should be used.
	//
	// When the command is selected the server should be contacted again (via the
	// `workspace/executeCommand`) request to execute the command.
	//
	// Since version 3.8.0: support for CodeAction literals to enable the following scenarios:
	//
	// - the ability to directly return a workspace edit from the code action request. This avoids
	// having another server roundtrip to execute an actual code action. However server providers
	// should be aware that if the code action is expensive to compute or the edits are huge it might
	// still be beneficial if the result is simply a command and the actual edit is only computed when
	// needed.
	//
	// - the ability to group code actions using a kind. Clients are allowed to ignore that
	// information. However it allows them to better group code action for example into corresponding
	// menus (e.g. all refactor code actions into a refactor menu).
	//
	// Clients need to announce their support for code action literals (e.g. literals of type
	// `CodeAction`) and code action kinds via the corresponding client capability
	// `codeAction.codeActionLiteralSupport`.
	CodeAction(ctx context.Context, in *CodeActionRequest, opts ...grpc.CallOption) (*CodeActionResponse, error)
	// CodeLens request is the code lens request is sent from the client to the server to compute code
	// lenses for a given text document.
	CodeLens(ctx context.Context, in *CodeLensRequest, opts ...grpc.CallOption) (*CodeLensResponse, error)
	// CodeLensResolve request is the code lens resolve request is sent from the client to the server
	// to resolve the command for a given code lens item.
	CodeLensResolve(ctx context.Context, in *CodeLensResolveRequest, opts ...grpc.CallOption) (*CodeLensResolveResponse, error)
	// DocumentLink request is the document links request is sent from the client to the server to
	// request the location of links in a document.
	DocumentLink(ctx context.Context, in *DocumentLinkRequest, opts ...grpc.CallOption) (*DocumentLinkResponse, error)
	// DocumentLinkResolve request is the document link resolve request is sent from the client to the
	// server to resolve the target of a given document link.
	DocumentLinkResolve(ctx context.Context, in *DocumentLinkResolveRequest, opts ...grpc.CallOption) (*DocumentLinkResolveResponse, error)
	// DocumentColor request is the document color request is sent from the client to the server to
	// list all color references found in a given text document. Along with the range, a color value
	// in RGB is returned.
	//
	// Clients can use the result to decorate color references in an editor. For example:
	//
	// - Color boxes showing the actual color next to the reference
	//
	// - Show a color picker when a color reference is edited
	//
	// @since 3.6.0
	DocumentColor(ctx context.Context, in *DocumentColorRequest, opts ...grpc.CallOption) (*DocumentColorResponse, error)
	// ColorPresentation request is the color presentation request is sent from the client to the
	// server to obtain a list of presentations for a color value at a given location. Clients can use
	// the result to
	//
	// - modify a color reference.
	// - show in a color picker and let users pick one of the presentations
	//
	// This request has no special capabilities and registration options since it is send as a resolve
	// request for the `textDocument/documentColor` request.
	//
	// @since 3.6.0
	ColorPresentation(ctx context.Context, in *ColorPresentationRequest, opts ...grpc.CallOption) (*ColorPresentationResponse, error)
	// DocumentFormatting request is the document formatting request is sent from the client to the
	// server to format a whole document.
	DocumentFormatting(ctx context.Context, in *DocumentFormattingRequest, opts ...grpc.CallOption) (*DocumentFormattingResponse, error)
	// DocumentRangeFormatting Request is the document range formatting request is sent from the
	// client to the server to format a given range in a document.
	DocumentRangeFormatting(ctx context.Context, in *DocumentRangeFormattingRequest, opts ...grpc.CallOption) (*DocumentRangeFormattingResponse, error)
	// OnTypeFormatting request is the document on type formatting request is sent from the client to
	// the server to format parts of the document during typing.
	OnTypeFormatting(ctx context.Context, in *DocumentOnTypeFormattingRequest, opts ...grpc.CallOption) (*DocumentOnTypeFormattingResponse, error)
	// Rename request is the rename request is sent from the client to the server to ask the server to
	// compute a workspace change so that the client can perform a workspace-wide rename of a symbol.
	Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error)
	// PrepareRename request is the prepare rename request is sent from the client to the server to
	// setup and test the validity of a rename operation at a given location.
	//
	// @since 3.12.0
	PrepareRename(ctx context.Context, in *PrepareRenameRequest, opts ...grpc.CallOption) (*PrepareRenameResponse, error)
	// FoldingRange request is the folding range request is sent from the client to the server to
	// return all folding ranges found in a given text document.
	//
	// @since 3.10.0
	FoldingRange(ctx context.Context, in *FoldingRangeRequest, opts ...grpc.CallOption) (*FoldingRangeResponse, error)
	// SelectionRange request is the selection range request is sent from the client to the server to
	// return suggested selection ranges at an array of given positions.
	//
	// A selection range is a range around the cursor position which the user might be interested in
	// selecting. A selection range in the return array is for the position in the provided parameters
	// at the same index. Therefore positions[i] must be contained in result[i].range.
	//
	// Typically, but not necessary, selection ranges correspond to the nodes of the syntax tree.
	//
	// @since 3.15.0
	SelectionRange(ctx context.Context, in *SelectionRangeRequest, opts ...grpc.CallOption) (*SelectionRangeResponse, error)
	// PrepareCallHierarchy request is the call hierarchy request is sent from the client to the
	// server to return a call hierarchy for the language element of given text document positions.
	//
	// The call hierarchy requests are executed in two steps:
	//
	// - first a call hierarchy item is resolved for the given text document position
	//
	// - for a call hierarchy item the incoming or outgoing call hierarchy items are resolved.
	//
	// @since 3.16.0
	PrepareCallHierarchy(ctx context.Context, in *CallHierarchyPrepareRequest, opts ...grpc.CallOption) (*CallHierarchyPrepareResponse, error)
	// CallHierarchyIncomingCalls request is sent from the client to the server to resolve incoming
	// calls for a given call hierarchy item.
	//
	// The request doesn’t define its own client and server capabilities. It is only issued if a
	// server registers for the `textDocument/prepareCallHierarchy` request.
	//
	// @since 3.16.0
	CallHierarchyIncomingCalls(ctx context.Context, in *CallHierarchyIncomingCallsRequest, opts ...grpc.CallOption) (*CallHierarchyIncomingCallsResponse, error)
	// CallHierarchyOutgoingCalls is the request is sent from the client to the server to resolve
	// outgoing calls for a given call hierarchy item.
	//
	// The request doesn’t define its own client and server capabilities. It is only issued if a
	// server registers for the textDocument/prepareCallHierarchy request.
	//
	// @since 3.16.0
	CallHierarchyOutgoingCalls(ctx context.Context, in *CallHierarchyOutgoingCallsRequest, opts ...grpc.CallOption) (*CallHierarchyOutgoingCallsResponse, error)
}

type languageServerProtocolClient struct {
	cc grpc.ClientConnInterface
}

func NewLanguageServerProtocolClient(cc grpc.ClientConnInterface) LanguageServerProtocolClient {
	return &languageServerProtocolClient{cc}
}

func (c *languageServerProtocolClient) Cancel(ctx context.Context, in *CancelRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Cancel", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Progress(ctx context.Context, in *ProgressRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Progress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Initialize(ctx context.Context, in *InitializeRequest, opts ...grpc.CallOption) (*InitializeResponse, error) {
	out := new(InitializeResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Initialize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Initialized(ctx context.Context, in *InitializedRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Initialized", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Shutdown(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*protocol.Error, error) {
	out := new(protocol.Error)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Shutdown", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Exit(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Exit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) LogTrace(ctx context.Context, in *LogTraceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/LogTrace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) SetTrace(ctx context.Context, in *SetTraceRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/SetTrace", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) ShowMessage(ctx context.Context, in *ShowMessageRequestParams, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/ShowMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) ShowMessageRequest(ctx context.Context, in *ShowMessageRequestRequest, opts ...grpc.CallOption) (*ShowMessageResponse, error) {
	out := new(ShowMessageResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/ShowMessageRequest", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) LogMessage(ctx context.Context, in *LogMessageRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/LogMessage", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CreateWorkDoneProgress(ctx context.Context, in *WorkDoneProgressCreateRequest, opts ...grpc.CallOption) (*protocol.Error, error) {
	out := new(protocol.Error)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CreateWorkDoneProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CancelWorkDoneProgress(ctx context.Context, in *WorkDoneProgressCancelRequest, opts ...grpc.CallOption) (*protocol.Error, error) {
	out := new(protocol.Error)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CancelWorkDoneProgress", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Telemetry(ctx context.Context, in *anypb.Any, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Telemetry", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) WorkspaceFolders(ctx context.Context, in *emptypb.Empty, opts ...grpc.CallOption) (*WorkspaceFoldersResponse, error) {
	out := new(WorkspaceFoldersResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/WorkspaceFolders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidChangeWorkspaceFolders(ctx context.Context, in *DidChangeWorkspaceFoldersRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidChangeWorkspaceFolders", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidChangeConfiguration(ctx context.Context, in *DidChangeConfigurationRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidChangeConfiguration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Configuration(ctx context.Context, in *ConfigurationRequest, opts ...grpc.CallOption) (*ConfigurationResponse, error) {
	out := new(ConfigurationResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Configuration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidChangeWatchedFiles(ctx context.Context, in *DidChangeWatchedFilesRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidChangeWatchedFiles", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) WorkspaceSymbols(ctx context.Context, in *ConfigurationRequest, opts ...grpc.CallOption) (*WorkspaceSymbolsResponse, error) {
	out := new(WorkspaceSymbolsResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/WorkspaceSymbols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) ExecuteCommand(ctx context.Context, in *ExecuteCommandParams, opts ...grpc.CallOption) (*ExecuteCommandResponse, error) {
	out := new(ExecuteCommandResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/ExecuteCommand", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) ApplyEdit(ctx context.Context, in *ApplyWorkspaceEditRequest, opts ...grpc.CallOption) (*ApplyWorkspaceEditResponse, error) {
	out := new(ApplyWorkspaceEditResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/ApplyEdit", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidOpenTextDocument(ctx context.Context, in *DidOpenTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidOpenTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidChangeTextDocument(ctx context.Context, in *DidChangeTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidChangeTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) WillSaveTextDocument(ctx context.Context, in *WillSaveTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/WillSaveTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) WillSaveWaitUntilTextDocument(ctx context.Context, in *WillSaveTextDocumentRequest, opts ...grpc.CallOption) (*WillSaveTextDocumentResponse, error) {
	out := new(WillSaveTextDocumentResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/WillSaveWaitUntilTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidSaveTextDocument(ctx context.Context, in *DidSaveTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidSaveTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DidCloseTextDocument(ctx context.Context, in *DidCloseTextDocumentRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DidCloseTextDocument", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) PublishDiagnostics(ctx context.Context, in *PublishDiagnosticsRequest, opts ...grpc.CallOption) (*emptypb.Empty, error) {
	out := new(emptypb.Empty)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/PublishDiagnostics", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Completion(ctx context.Context, in *CompletionRequest, opts ...grpc.CallOption) (*CompletionResponse, error) {
	out := new(CompletionResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Completion", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CompletionItemResolve(ctx context.Context, in *CompletionItemResolveRequest, opts ...grpc.CallOption) (*CompletionItemResolveResponse, error) {
	out := new(CompletionItemResolveResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CompletionItemResolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Hover(ctx context.Context, in *HoverRequest, opts ...grpc.CallOption) (*HoverResponse, error) {
	out := new(HoverResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Hover", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) SignatureHelp(ctx context.Context, in *SignatureHelpRequest, opts ...grpc.CallOption) (*SignatureHelpResponse, error) {
	out := new(SignatureHelpResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/SignatureHelp", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) GotoDeclaration(ctx context.Context, in *DeclarationRequest, opts ...grpc.CallOption) (*DeclarationResponse, error) {
	out := new(DeclarationResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/GotoDeclaration", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) GotoDefinition(ctx context.Context, in *DefinitionRequest, opts ...grpc.CallOption) (*DefinitionResponse, error) {
	out := new(DefinitionResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/GotoDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) GotoTypeDefinition(ctx context.Context, in *TypeDefinitionRequest, opts ...grpc.CallOption) (*TypeDefinitionResponse, error) {
	out := new(TypeDefinitionResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/GotoTypeDefinition", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) GotoImplementation(ctx context.Context, in *ImplementationRequest, opts ...grpc.CallOption) (*ImplementationResponse, error) {
	out := new(ImplementationResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/GotoImplementation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) FindReferences(ctx context.Context, in *ReferenceRequest, opts ...grpc.CallOption) (*ReferenceResponse, error) {
	out := new(ReferenceResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/FindReferences", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentHighlights(ctx context.Context, in *DocumentHighlightRequest, opts ...grpc.CallOption) (*DocumentHighlightsResponse, error) {
	out := new(DocumentHighlightsResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentHighlights", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentSymbols(ctx context.Context, in *DocumentSymbolRequest, opts ...grpc.CallOption) (*DocumentSymbolResponse, error) {
	out := new(DocumentSymbolResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentSymbols", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CodeAction(ctx context.Context, in *CodeActionRequest, opts ...grpc.CallOption) (*CodeActionResponse, error) {
	out := new(CodeActionResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CodeAction", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CodeLens(ctx context.Context, in *CodeLensRequest, opts ...grpc.CallOption) (*CodeLensResponse, error) {
	out := new(CodeLensResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CodeLens", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CodeLensResolve(ctx context.Context, in *CodeLensResolveRequest, opts ...grpc.CallOption) (*CodeLensResolveResponse, error) {
	out := new(CodeLensResolveResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CodeLensResolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentLink(ctx context.Context, in *DocumentLinkRequest, opts ...grpc.CallOption) (*DocumentLinkResponse, error) {
	out := new(DocumentLinkResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentLink", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentLinkResolve(ctx context.Context, in *DocumentLinkResolveRequest, opts ...grpc.CallOption) (*DocumentLinkResolveResponse, error) {
	out := new(DocumentLinkResolveResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentLinkResolve", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentColor(ctx context.Context, in *DocumentColorRequest, opts ...grpc.CallOption) (*DocumentColorResponse, error) {
	out := new(DocumentColorResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentColor", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) ColorPresentation(ctx context.Context, in *ColorPresentationRequest, opts ...grpc.CallOption) (*ColorPresentationResponse, error) {
	out := new(ColorPresentationResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/ColorPresentation", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentFormatting(ctx context.Context, in *DocumentFormattingRequest, opts ...grpc.CallOption) (*DocumentFormattingResponse, error) {
	out := new(DocumentFormattingResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentFormatting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) DocumentRangeFormatting(ctx context.Context, in *DocumentRangeFormattingRequest, opts ...grpc.CallOption) (*DocumentRangeFormattingResponse, error) {
	out := new(DocumentRangeFormattingResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/DocumentRangeFormatting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) OnTypeFormatting(ctx context.Context, in *DocumentOnTypeFormattingRequest, opts ...grpc.CallOption) (*DocumentOnTypeFormattingResponse, error) {
	out := new(DocumentOnTypeFormattingResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/OnTypeFormatting", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) Rename(ctx context.Context, in *RenameRequest, opts ...grpc.CallOption) (*RenameResponse, error) {
	out := new(RenameResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/Rename", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) PrepareRename(ctx context.Context, in *PrepareRenameRequest, opts ...grpc.CallOption) (*PrepareRenameResponse, error) {
	out := new(PrepareRenameResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/PrepareRename", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) FoldingRange(ctx context.Context, in *FoldingRangeRequest, opts ...grpc.CallOption) (*FoldingRangeResponse, error) {
	out := new(FoldingRangeResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/FoldingRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) SelectionRange(ctx context.Context, in *SelectionRangeRequest, opts ...grpc.CallOption) (*SelectionRangeResponse, error) {
	out := new(SelectionRangeResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/SelectionRange", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) PrepareCallHierarchy(ctx context.Context, in *CallHierarchyPrepareRequest, opts ...grpc.CallOption) (*CallHierarchyPrepareResponse, error) {
	out := new(CallHierarchyPrepareResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/PrepareCallHierarchy", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CallHierarchyIncomingCalls(ctx context.Context, in *CallHierarchyIncomingCallsRequest, opts ...grpc.CallOption) (*CallHierarchyIncomingCallsResponse, error) {
	out := new(CallHierarchyIncomingCallsResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CallHierarchyIncomingCalls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *languageServerProtocolClient) CallHierarchyOutgoingCalls(ctx context.Context, in *CallHierarchyOutgoingCallsRequest, opts ...grpc.CallOption) (*CallHierarchyOutgoingCallsResponse, error) {
	out := new(CallHierarchyOutgoingCallsResponse)
	err := c.cc.Invoke(ctx, "/protocol.rpc.LanguageServerProtocol/CallHierarchyOutgoingCalls", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// LanguageServerProtocolServer is the server API for LanguageServerProtocol service.
// All implementations must embed UnimplementedLanguageServerProtocolServer
// for forward compatibility
type LanguageServerProtocolServer interface {
	// Cancel notification is the base protocol offers support for request cancellation. To cancel a
	// request, a CancelRequest notification message is sent.
	//
	// A request that got canceled still needs to return from the server and send a response back. It
	// can not be left open / hanging. This is in line with the JSON RPC protocol that requires that
	// every request sends a response back. In addition it allows for returning partial results on
	// cancel. If the request returns an error response on cancellation it is advised to set the error
	// code to [Codes.RequestCancelled][protocol.Codes].
	Cancel(context.Context, *CancelRequest) (*emptypb.Empty, error)
	// Progress notification is the base protocol offers also support to report progress in a generic
	// fashion. This mechanism can be used to report any kind of progress including work done progress
	// (usually used to report progress in the user interface using a progress bar) and partial result
	// progress to support streaming of results.
	//
	// Progress is reported against a token. The token is different than the request ID which allows
	// to report progress out of band and also for notification.
	//
	// @since 3.15.0
	Progress(context.Context, *ProgressRequest) (*emptypb.Empty, error)
	// Initialize request is sent as the first request from the client to the server. If the server
	// receives a request or notification before the initialize request it should act as follows:
	//
	// - For a request the response should be an error with `code: -32002`. The message can be picked
	// by the server.
	// - Notifications should be dropped, except for the exit notification. This will allow the exit
	// of a server without an initialize request.
	//
	// Until the server has responded to the `initialize` request with an `InitializeResponse`, the
	// client must not send any additional requests or notifications to the server. In addition the
	// server is not allowed to send any requests or notifications to the client until it has
	// responded with an `InitializeResponse`, with the exception that during the initialize request
	// the server is allowed to send the notifications `window/showMessage`, `window/logMessage` and
	// `telemetry/event` as well as the `window/showMessageRequest` request to the client. In case the
	// client sets up a progress token in the initialize params (e.g. property `workDoneToken`) the
	// server is also allowed to use that token (and only that token) using the `$/progress`
	// notification sent from the server to the client.
	//
	// The initialize request may only be sent once.
	Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error)
	// Initialized notification is sent from the client to the server after the client received the
	// result of the `initialize` request but before the client is sending any other request or
	// notification to the server.
	//
	// The server can use the `initialized` notification for example to dynamically register
	// capabilities.
	//
	// The `initialized` notification may only be sent once.
	Initialized(context.Context, *InitializedRequest) (*emptypb.Empty, error)
	// Shutdown request is sent from the client to the server.
	//
	// It asks the server to shut down, but to not exit (otherwise the response might not be delivered
	// correctly to the client). There is a separate exit notification that asks the server to exit.
	//
	// Clients must not send any notifications other than exit or requests to a server to which they
	// have sent a shutdown request.
	//
	// If a server receives requests after a shutdown request those requests should error with
	// `InvalidRequest`.
	Shutdown(context.Context, *emptypb.Empty) (*protocol.Error, error)
	// Exit notification to ask the server to exit its process.
	//
	// The server should exit with `success` code 0 if the shutdown request has been received before;
	// otherwise with `error` code 1.
	Exit(context.Context, *emptypb.Empty) (*emptypb.Empty, error)
	// LogTrace notification to log the trace of the server’s execution.
	//
	// The amount and content of these notifications depends on the current `trace` configuration.
	// If `trace` is `'off'`, the server should not send any `logTrace` notification. If `trace` is
	// `'message'`, the server should not add the `'verbose'` field in the logTraceRequest.
	//
	// `$/logTrace` should be used for systematic trace reporting. For single debugging messages, the
	// server should send window/logMessage notifications.
	LogTrace(context.Context, *LogTraceRequest) (*emptypb.Empty, error)
	// SetTrace notification that should be used by the client to modify the trace setting of the
	// server.
	//
	// (-- api-linter: core::0134::synonyms=disabled
	//     api-linter: core::0136::http-method=disabled --)
	SetTrace(context.Context, *SetTraceRequest) (*emptypb.Empty, error)
	// ShowMessage notification is the show message notification is sent from a server to a client to
	// ask the client to display a particular message in the user interface.
	ShowMessage(context.Context, *ShowMessageRequestParams) (*emptypb.Empty, error)
	// ShowMessageRequest request is the show message request is sent from a server to a client to ask
	// the client to display a particular message in the user interface. In addition to the show
	// message notification the request allows to pass actions and to wait for an answer from the
	// client.
	ShowMessageRequest(context.Context, *ShowMessageRequestRequest) (*ShowMessageResponse, error)
	// LogMessage notification is the log message notification is sent from the server to the client
	// to ask the client to log a particular message.
	LogMessage(context.Context, *LogMessageRequest) (*emptypb.Empty, error)
	// CreateWorkDoneProgress is the `window/workDoneProgress/create` request is sent from the server
	// to the client to ask the client to create a work done progress.
	//
	// (-- api-linter: core::0133::http-uri-parent=disabled
	//     api-linter: core::0133::http-body=disabled
	//     api-linter: core::0133::request-message-name=disabled
	//     api-linter: core::0133::response-message-name=disabled --)
	CreateWorkDoneProgress(context.Context, *WorkDoneProgressCreateRequest) (*protocol.Error, error)
	// CancelWorkDoneProgress is the `window/workDoneProgress/cancel` notification is sent from the
	// client to the server to cancel a progress initiated on the server side using the
	// `window/workDoneProgress/create`.
	CancelWorkDoneProgress(context.Context, *WorkDoneProgressCancelRequest) (*protocol.Error, error)
	// Telemetry notification is the telemetry notification is sent from the server to the client to
	// ask the client to log a telemetry event.
	Telemetry(context.Context, *anypb.Any) (*emptypb.Empty, error)
	// WorkspaceFolders request is the workspace/workspaceFolders request is sent from the server to
	// the client to fetch the current open list of workspace folders.
	//
	// Returns null in the response if only a single file is open in the tool. Returns an empty array
	// if a workspace is open but no folders are configured.
	//
	// @since 3.6.0
	WorkspaceFolders(context.Context, *emptypb.Empty) (*WorkspaceFoldersResponse, error)
	// DidChangeWorkspaceFolders notification is the `workspace/didChangeWorkspaceFolders`
	// notification is sent from the client to the server to inform the server about workspace folder
	// configuration changes.
	//
	// The notification is sent by default if both client capability `workspace.workspaceFolders` and
	// the server capability `workspace.workspaceFolders.supported` are true; or if the server has
	// registered itself to receive this notification. To register for the
	// `workspace/didChangeWorkspaceFolders` send a client/registerCapability request from the server
	// to the client. The `registration` parameter must have a registrations item of the following
	// form, where id is a unique id used to unregister the capability (the example uses a UUID):
	//
	// @since 3.6.0
	DidChangeWorkspaceFolders(context.Context, *DidChangeWorkspaceFoldersRequest) (*emptypb.Empty, error)
	// DidChangeConfiguration a notification sent from the client to the server to signal the change
	// of configuration settings.
	DidChangeConfiguration(context.Context, *DidChangeConfigurationRequest) (*emptypb.Empty, error)
	// Configuration request is the `workspace/configuration` request is sent from the server to the
	// client to fetch configuration settings from the client.
	//
	// The request can fetch several configuration settings in one roundtrip. The order of the
	// returned configuration settings correspond to the order of the passed `ConfigurationItems`
	// (e.g. the first item in the response is the result for the first configuration item in the
	// params).
	//
	// @since 3.6.0
	Configuration(context.Context, *ConfigurationRequest) (*ConfigurationResponse, error)
	// DidChangeWatchedFiles notification is the watched files notification is sent from the client to
	// the server when the client detects changes to files watched by the language client.
	//
	// It is recommended that servers register for these file events using the registration mechanism.
	// In former implementations clients pushed file events without the server actively asking for it.
	DidChangeWatchedFiles(context.Context, *DidChangeWatchedFilesRequest) (*emptypb.Empty, error)
	// WorkspaceSymbols request is the workspace symbol request is sent from the client to the server
	// to list project-wide symbols matching the query string.
	//
	// (-- api-linter: core::0136::http-uri-suffix=disabled --)
	WorkspaceSymbols(context.Context, *ConfigurationRequest) (*WorkspaceSymbolsResponse, error)
	// ExecuteCommand is the `workspace/executeCommand` request is sent from the client to the server
	// to trigger command execution on the server.
	//
	// In most cases the server creates a `WorkspaceEdit` structure and applies the changes to the
	// workspace using the request `workspace/applyEdit` which is sent from the server to the client.
	ExecuteCommand(context.Context, *ExecuteCommandParams) (*ExecuteCommandResponse, error)
	// ApplyEdit request is sent from the server to the client to modify resource on the client side.
	ApplyEdit(context.Context, *ApplyWorkspaceEditRequest) (*ApplyWorkspaceEditResponse, error)
	// DidOpenTextDocument notification is the `DidOpenTextDocumentRequest` contain the language id
	// the document is associated with.
	//
	// If the language Id of a document changes, the client needs to send a `textDocument/didClose` to
	// the server followed by a `textDocument/didOpen` with the new language id if the server handles
	// the new language id as well.
	DidOpenTextDocument(context.Context, *DidOpenTextDocumentRequest) (*emptypb.Empty, error)
	// DidChangeTextDocument notification is the document change notification is sent from the client
	// to the server to signal changes to a text document.
	//
	// Before a client can change a text document it must claim ownership of its content using the
	// textDocument/didOpen notification.
	//
	// In 2.0 the shape of the params has changed to include proper version numbers and language ids.
	DidChangeTextDocument(context.Context, *DidChangeTextDocumentRequest) (*emptypb.Empty, error)
	// WillSaveTextDocument notification is the document will save notification is sent from the
	// client to the server before the document is actually saved.
	WillSaveTextDocument(context.Context, *WillSaveTextDocumentRequest) (*emptypb.Empty, error)
	// WillSaveWaitUntilTextDocument request is the document will save request is sent from the client
	// to the server before the document is actually saved.
	//
	// The request can return an array of TextEdits which will be applied to the text document before
	// it is saved.
	//
	// Please note that clients might drop results if computing the text edits took too long or if a
	// server constantly fails on this request. This is done to keep the save fast and reliable.
	WillSaveWaitUntilTextDocument(context.Context, *WillSaveTextDocumentRequest) (*WillSaveTextDocumentResponse, error)
	// DidSaveTextDocument notification is the document save notification is sent from the client to
	// the server when the document was saved in the client.
	DidSaveTextDocument(context.Context, *DidSaveTextDocumentRequest) (*emptypb.Empty, error)
	// DidCloseTextDocument notification is the document close notification is sent from the client to
	// the server when the document got closed in the client.
	//
	// The document’s master now exists where the document’s Uri points to (e.g. if the document’s Uri
	// is a file Uri the master now exists on disk). As with the open notification the close
	// notification is about managing the document’s content.
	//
	// Receiving a close notification doesn’t mean that the document was open in an editor before. A
	// close notification requires a previous open notification to be sent. Note that a server’s
	// ability to fulfill requests is independent of whether a text document is open or closed.
	DidCloseTextDocument(context.Context, *DidCloseTextDocumentRequest) (*emptypb.Empty, error)
	// PublishDiagnostics notification is the diagnostics notification are sent from the server to the
	// client to signal results of validation runs.
	PublishDiagnostics(context.Context, *PublishDiagnosticsRequest) (*emptypb.Empty, error)
	// Completion request is the Completion request is sent from the client to the server to compute
	// completion items at a given cursor position.
	//
	// Completion items are presented in the IntelliSense user interface. If computing full completion
	// items is expensive, servers can additionally provide a handler for the completion item resolve
	// request (‘completionItem/resolve’).
	//
	// This request is sent when a completion item is selected in the user interface. A typical use
	// case is for example: the `textDocument/completion` request doesn’t fill in the documentation
	// property for returned completion items since it is expensive to compute. When the item is
	// selected in the user interface then a `completionItem/resolve` request is sent with the
	// selected completion item as a parameter.
	//
	// The returned completion item should have the documentation property filled in. The request can
	// only delay the computation of the `detail` and `documentation` properties. Other properties
	// like `sortText`, `filterText`, `insertText`, `textEdit` and `additionalTextEdits` must be
	// provided in the `textDocument/completion` response and must not be changed during resolve.
	Completion(context.Context, *CompletionRequest) (*CompletionResponse, error)
	// CompletionItemResolve request is the request is sent from the client to the server to resolve
	// additional information for a given completion item.
	CompletionItemResolve(context.Context, *CompletionItemResolveRequest) (*CompletionItemResolveResponse, error)
	// Hover Request is the hover request is sent from the client to the server to request hover
	// information at a given text document position.
	Hover(context.Context, *HoverRequest) (*HoverResponse, error)
	// SignatureHelp request is the signature help request is sent from the client to the server to
	// request signature information at a given cursor position.
	SignatureHelp(context.Context, *SignatureHelpRequest) (*SignatureHelpResponse, error)
	// GotoDeclaration request is the go to declaration request is sent from the client to the server
	// to resolve the declaration location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.declaration.linkSupport`.
	//
	// @since 3.14.0
	GotoDeclaration(context.Context, *DeclarationRequest) (*DeclarationResponse, error)
	// GotoDefinition request is the go to definition request is sent from the client to the server to
	// resolve the definition location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.definition.linkSupport`.
	GotoDefinition(context.Context, *DefinitionRequest) (*DefinitionResponse, error)
	// GotoTypeDefinition request is the go to type definition request is sent from the client to the
	// server to resolve the type definition location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.typeDefinition.linkSupport`.
	//
	// @since 3.6.0
	GotoTypeDefinition(context.Context, *TypeDefinitionRequest) (*TypeDefinitionResponse, error)
	// GotoImplementation request is the go to implementation request is sent from the client to the
	// server to resolve the implementation location of a symbol at a given text document position.
	//
	// The result type [LocationLinks][LocationLinks] got introduced with version 3.14.0 and depends
	// on the corresponding client capability `textDocument.implementation.linkSupport`.
	//
	// @since 3.6.0
	GotoImplementation(context.Context, *ImplementationRequest) (*ImplementationResponse, error)
	// FindReferences request is the references request is sent from the client to the server to
	// resolve project-wide references for the symbol denoted by the given text document position.
	FindReferences(context.Context, *ReferenceRequest) (*ReferenceResponse, error)
	// DocumentHighlights request is the document highlight request is sent from the client to the
	// server to resolve a document highlights for a given text document position.
	//
	// For programming languages this usually highlights all references to the symbol scoped to this
	// file. However we kept `textDocument/documentHighlight` and `textDocument/references` separate
	// requests since the first one is allowed to be more fuzzy.
	//
	// Symbol matches usually have a DocumentHighlightKind of `Read` or `Write` whereas fuzzy or
	// textual matches use `Text` as the kind.
	DocumentHighlights(context.Context, *DocumentHighlightRequest) (*DocumentHighlightsResponse, error)
	// DocumentSymbols request is the document symbol request is sent from the client to the server.
	//
	// The returned result is either
	//
	// - SymbolInformation[] which is a flat list of all symbols found in a given text document. Then
	// neither the symbol’s location range nor the symbol’s container name should be used to infer a
	// hierarchy.
	//
	// - DocumentSymbol[] which is a hierarchy of symbols found in a given text document.
	DocumentSymbols(context.Context, *DocumentSymbolRequest) (*DocumentSymbolResponse, error)
	// CodeAction request is the code action request is sent from the client to the server to compute
	// commands for a given text document and range.
	//
	// These commands are typically code fixes to either fix problems or to beautify/refactor code.
	//
	// The result of a `textDocument/codeAction` request is an array of `Command` literals which are
	// typically presented in the user interface. To ensure that a server is useful in many clients
	// the commands specified in a code actions should be handled by the server and not by the client
	// (see `workspace/executeCommand` and `ServerCapabilities.executeCommandProvider`). If the client
	// supports providing edits with a code action then the mode should be used.
	//
	// When the command is selected the server should be contacted again (via the
	// `workspace/executeCommand`) request to execute the command.
	//
	// Since version 3.8.0: support for CodeAction literals to enable the following scenarios:
	//
	// - the ability to directly return a workspace edit from the code action request. This avoids
	// having another server roundtrip to execute an actual code action. However server providers
	// should be aware that if the code action is expensive to compute or the edits are huge it might
	// still be beneficial if the result is simply a command and the actual edit is only computed when
	// needed.
	//
	// - the ability to group code actions using a kind. Clients are allowed to ignore that
	// information. However it allows them to better group code action for example into corresponding
	// menus (e.g. all refactor code actions into a refactor menu).
	//
	// Clients need to announce their support for code action literals (e.g. literals of type
	// `CodeAction`) and code action kinds via the corresponding client capability
	// `codeAction.codeActionLiteralSupport`.
	CodeAction(context.Context, *CodeActionRequest) (*CodeActionResponse, error)
	// CodeLens request is the code lens request is sent from the client to the server to compute code
	// lenses for a given text document.
	CodeLens(context.Context, *CodeLensRequest) (*CodeLensResponse, error)
	// CodeLensResolve request is the code lens resolve request is sent from the client to the server
	// to resolve the command for a given code lens item.
	CodeLensResolve(context.Context, *CodeLensResolveRequest) (*CodeLensResolveResponse, error)
	// DocumentLink request is the document links request is sent from the client to the server to
	// request the location of links in a document.
	DocumentLink(context.Context, *DocumentLinkRequest) (*DocumentLinkResponse, error)
	// DocumentLinkResolve request is the document link resolve request is sent from the client to the
	// server to resolve the target of a given document link.
	DocumentLinkResolve(context.Context, *DocumentLinkResolveRequest) (*DocumentLinkResolveResponse, error)
	// DocumentColor request is the document color request is sent from the client to the server to
	// list all color references found in a given text document. Along with the range, a color value
	// in RGB is returned.
	//
	// Clients can use the result to decorate color references in an editor. For example:
	//
	// - Color boxes showing the actual color next to the reference
	//
	// - Show a color picker when a color reference is edited
	//
	// @since 3.6.0
	DocumentColor(context.Context, *DocumentColorRequest) (*DocumentColorResponse, error)
	// ColorPresentation request is the color presentation request is sent from the client to the
	// server to obtain a list of presentations for a color value at a given location. Clients can use
	// the result to
	//
	// - modify a color reference.
	// - show in a color picker and let users pick one of the presentations
	//
	// This request has no special capabilities and registration options since it is send as a resolve
	// request for the `textDocument/documentColor` request.
	//
	// @since 3.6.0
	ColorPresentation(context.Context, *ColorPresentationRequest) (*ColorPresentationResponse, error)
	// DocumentFormatting request is the document formatting request is sent from the client to the
	// server to format a whole document.
	DocumentFormatting(context.Context, *DocumentFormattingRequest) (*DocumentFormattingResponse, error)
	// DocumentRangeFormatting Request is the document range formatting request is sent from the
	// client to the server to format a given range in a document.
	DocumentRangeFormatting(context.Context, *DocumentRangeFormattingRequest) (*DocumentRangeFormattingResponse, error)
	// OnTypeFormatting request is the document on type formatting request is sent from the client to
	// the server to format parts of the document during typing.
	OnTypeFormatting(context.Context, *DocumentOnTypeFormattingRequest) (*DocumentOnTypeFormattingResponse, error)
	// Rename request is the rename request is sent from the client to the server to ask the server to
	// compute a workspace change so that the client can perform a workspace-wide rename of a symbol.
	Rename(context.Context, *RenameRequest) (*RenameResponse, error)
	// PrepareRename request is the prepare rename request is sent from the client to the server to
	// setup and test the validity of a rename operation at a given location.
	//
	// @since 3.12.0
	PrepareRename(context.Context, *PrepareRenameRequest) (*PrepareRenameResponse, error)
	// FoldingRange request is the folding range request is sent from the client to the server to
	// return all folding ranges found in a given text document.
	//
	// @since 3.10.0
	FoldingRange(context.Context, *FoldingRangeRequest) (*FoldingRangeResponse, error)
	// SelectionRange request is the selection range request is sent from the client to the server to
	// return suggested selection ranges at an array of given positions.
	//
	// A selection range is a range around the cursor position which the user might be interested in
	// selecting. A selection range in the return array is for the position in the provided parameters
	// at the same index. Therefore positions[i] must be contained in result[i].range.
	//
	// Typically, but not necessary, selection ranges correspond to the nodes of the syntax tree.
	//
	// @since 3.15.0
	SelectionRange(context.Context, *SelectionRangeRequest) (*SelectionRangeResponse, error)
	// PrepareCallHierarchy request is the call hierarchy request is sent from the client to the
	// server to return a call hierarchy for the language element of given text document positions.
	//
	// The call hierarchy requests are executed in two steps:
	//
	// - first a call hierarchy item is resolved for the given text document position
	//
	// - for a call hierarchy item the incoming or outgoing call hierarchy items are resolved.
	//
	// @since 3.16.0
	PrepareCallHierarchy(context.Context, *CallHierarchyPrepareRequest) (*CallHierarchyPrepareResponse, error)
	// CallHierarchyIncomingCalls request is sent from the client to the server to resolve incoming
	// calls for a given call hierarchy item.
	//
	// The request doesn’t define its own client and server capabilities. It is only issued if a
	// server registers for the `textDocument/prepareCallHierarchy` request.
	//
	// @since 3.16.0
	CallHierarchyIncomingCalls(context.Context, *CallHierarchyIncomingCallsRequest) (*CallHierarchyIncomingCallsResponse, error)
	// CallHierarchyOutgoingCalls is the request is sent from the client to the server to resolve
	// outgoing calls for a given call hierarchy item.
	//
	// The request doesn’t define its own client and server capabilities. It is only issued if a
	// server registers for the textDocument/prepareCallHierarchy request.
	//
	// @since 3.16.0
	CallHierarchyOutgoingCalls(context.Context, *CallHierarchyOutgoingCallsRequest) (*CallHierarchyOutgoingCallsResponse, error)
	mustEmbedUnimplementedLanguageServerProtocolServer()
}

// UnimplementedLanguageServerProtocolServer must be embedded to have forward compatible implementations.
type UnimplementedLanguageServerProtocolServer struct {
}

func (UnimplementedLanguageServerProtocolServer) Cancel(context.Context, *CancelRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Cancel not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Progress(context.Context, *ProgressRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Progress not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Initialize(context.Context, *InitializeRequest) (*InitializeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialize not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Initialized(context.Context, *InitializedRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Initialized not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Shutdown(context.Context, *emptypb.Empty) (*protocol.Error, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Shutdown not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Exit(context.Context, *emptypb.Empty) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Exit not implemented")
}

func (UnimplementedLanguageServerProtocolServer) LogTrace(context.Context, *LogTraceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogTrace not implemented")
}

func (UnimplementedLanguageServerProtocolServer) SetTrace(context.Context, *SetTraceRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SetTrace not implemented")
}

func (UnimplementedLanguageServerProtocolServer) ShowMessage(context.Context, *ShowMessageRequestParams) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowMessage not implemented")
}

func (UnimplementedLanguageServerProtocolServer) ShowMessageRequest(context.Context, *ShowMessageRequestRequest) (*ShowMessageResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ShowMessageRequest not implemented")
}

func (UnimplementedLanguageServerProtocolServer) LogMessage(context.Context, *LogMessageRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LogMessage not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CreateWorkDoneProgress(context.Context, *WorkDoneProgressCreateRequest) (*protocol.Error, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateWorkDoneProgress not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CancelWorkDoneProgress(context.Context, *WorkDoneProgressCancelRequest) (*protocol.Error, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CancelWorkDoneProgress not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Telemetry(context.Context, *anypb.Any) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Telemetry not implemented")
}

func (UnimplementedLanguageServerProtocolServer) WorkspaceFolders(context.Context, *emptypb.Empty) (*WorkspaceFoldersResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkspaceFolders not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidChangeWorkspaceFolders(context.Context, *DidChangeWorkspaceFoldersRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidChangeWorkspaceFolders not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidChangeConfiguration(context.Context, *DidChangeConfigurationRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidChangeConfiguration not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Configuration(context.Context, *ConfigurationRequest) (*ConfigurationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Configuration not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidChangeWatchedFiles(context.Context, *DidChangeWatchedFilesRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidChangeWatchedFiles not implemented")
}

func (UnimplementedLanguageServerProtocolServer) WorkspaceSymbols(context.Context, *ConfigurationRequest) (*WorkspaceSymbolsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WorkspaceSymbols not implemented")
}

func (UnimplementedLanguageServerProtocolServer) ExecuteCommand(context.Context, *ExecuteCommandParams) (*ExecuteCommandResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ExecuteCommand not implemented")
}

func (UnimplementedLanguageServerProtocolServer) ApplyEdit(context.Context, *ApplyWorkspaceEditRequest) (*ApplyWorkspaceEditResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ApplyEdit not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidOpenTextDocument(context.Context, *DidOpenTextDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidOpenTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidChangeTextDocument(context.Context, *DidChangeTextDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidChangeTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) WillSaveTextDocument(context.Context, *WillSaveTextDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WillSaveTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) WillSaveWaitUntilTextDocument(context.Context, *WillSaveTextDocumentRequest) (*WillSaveTextDocumentResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method WillSaveWaitUntilTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidSaveTextDocument(context.Context, *DidSaveTextDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidSaveTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DidCloseTextDocument(context.Context, *DidCloseTextDocumentRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DidCloseTextDocument not implemented")
}

func (UnimplementedLanguageServerProtocolServer) PublishDiagnostics(context.Context, *PublishDiagnosticsRequest) (*emptypb.Empty, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PublishDiagnostics not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Completion(context.Context, *CompletionRequest) (*CompletionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Completion not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CompletionItemResolve(context.Context, *CompletionItemResolveRequest) (*CompletionItemResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CompletionItemResolve not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Hover(context.Context, *HoverRequest) (*HoverResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Hover not implemented")
}

func (UnimplementedLanguageServerProtocolServer) SignatureHelp(context.Context, *SignatureHelpRequest) (*SignatureHelpResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SignatureHelp not implemented")
}

func (UnimplementedLanguageServerProtocolServer) GotoDeclaration(context.Context, *DeclarationRequest) (*DeclarationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GotoDeclaration not implemented")
}

func (UnimplementedLanguageServerProtocolServer) GotoDefinition(context.Context, *DefinitionRequest) (*DefinitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GotoDefinition not implemented")
}

func (UnimplementedLanguageServerProtocolServer) GotoTypeDefinition(context.Context, *TypeDefinitionRequest) (*TypeDefinitionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GotoTypeDefinition not implemented")
}

func (UnimplementedLanguageServerProtocolServer) GotoImplementation(context.Context, *ImplementationRequest) (*ImplementationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GotoImplementation not implemented")
}

func (UnimplementedLanguageServerProtocolServer) FindReferences(context.Context, *ReferenceRequest) (*ReferenceResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FindReferences not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentHighlights(context.Context, *DocumentHighlightRequest) (*DocumentHighlightsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentHighlights not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentSymbols(context.Context, *DocumentSymbolRequest) (*DocumentSymbolResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentSymbols not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CodeAction(context.Context, *CodeActionRequest) (*CodeActionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CodeAction not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CodeLens(context.Context, *CodeLensRequest) (*CodeLensResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CodeLens not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CodeLensResolve(context.Context, *CodeLensResolveRequest) (*CodeLensResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CodeLensResolve not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentLink(context.Context, *DocumentLinkRequest) (*DocumentLinkResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentLink not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentLinkResolve(context.Context, *DocumentLinkResolveRequest) (*DocumentLinkResolveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentLinkResolve not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentColor(context.Context, *DocumentColorRequest) (*DocumentColorResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentColor not implemented")
}

func (UnimplementedLanguageServerProtocolServer) ColorPresentation(context.Context, *ColorPresentationRequest) (*ColorPresentationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ColorPresentation not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentFormatting(context.Context, *DocumentFormattingRequest) (*DocumentFormattingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentFormatting not implemented")
}

func (UnimplementedLanguageServerProtocolServer) DocumentRangeFormatting(context.Context, *DocumentRangeFormattingRequest) (*DocumentRangeFormattingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DocumentRangeFormatting not implemented")
}

func (UnimplementedLanguageServerProtocolServer) OnTypeFormatting(context.Context, *DocumentOnTypeFormattingRequest) (*DocumentOnTypeFormattingResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method OnTypeFormatting not implemented")
}

func (UnimplementedLanguageServerProtocolServer) Rename(context.Context, *RenameRequest) (*RenameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Rename not implemented")
}

func (UnimplementedLanguageServerProtocolServer) PrepareRename(context.Context, *PrepareRenameRequest) (*PrepareRenameResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareRename not implemented")
}

func (UnimplementedLanguageServerProtocolServer) FoldingRange(context.Context, *FoldingRangeRequest) (*FoldingRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method FoldingRange not implemented")
}

func (UnimplementedLanguageServerProtocolServer) SelectionRange(context.Context, *SelectionRangeRequest) (*SelectionRangeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method SelectionRange not implemented")
}

func (UnimplementedLanguageServerProtocolServer) PrepareCallHierarchy(context.Context, *CallHierarchyPrepareRequest) (*CallHierarchyPrepareResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PrepareCallHierarchy not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CallHierarchyIncomingCalls(context.Context, *CallHierarchyIncomingCallsRequest) (*CallHierarchyIncomingCallsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallHierarchyIncomingCalls not implemented")
}

func (UnimplementedLanguageServerProtocolServer) CallHierarchyOutgoingCalls(context.Context, *CallHierarchyOutgoingCallsRequest) (*CallHierarchyOutgoingCallsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CallHierarchyOutgoingCalls not implemented")
}

func (UnimplementedLanguageServerProtocolServer) mustEmbedUnimplementedLanguageServerProtocolServer() {
}

// UnsafeLanguageServerProtocolServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to LanguageServerProtocolServer will
// result in compilation errors.
type UnsafeLanguageServerProtocolServer interface {
	mustEmbedUnimplementedLanguageServerProtocolServer()
}

func RegisterLanguageServerProtocolServer(s grpc.ServiceRegistrar, srv LanguageServerProtocolServer) {
	s.RegisterService(&_LanguageServerProtocol_serviceDesc, srv)
}

func _LanguageServerProtocol_Cancel_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Cancel(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Cancel",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Cancel(ctx, req.(*CancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Progress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ProgressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Progress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Progress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Progress(ctx, req.(*ProgressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Initialize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Initialize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Initialize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Initialize(ctx, req.(*InitializeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Initialized_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InitializedRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Initialized(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Initialized",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Initialized(ctx, req.(*InitializedRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Shutdown_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Shutdown(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Shutdown",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Shutdown(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Exit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Exit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Exit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Exit(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_LogTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).LogTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/LogTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).LogTrace(ctx, req.(*LogTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_SetTrace_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SetTraceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).SetTrace(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/SetTrace",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).SetTrace(ctx, req.(*SetTraceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_ShowMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowMessageRequestParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).ShowMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/ShowMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).ShowMessage(ctx, req.(*ShowMessageRequestParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_ShowMessageRequest_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ShowMessageRequestRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).ShowMessageRequest(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/ShowMessageRequest",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).ShowMessageRequest(ctx, req.(*ShowMessageRequestRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_LogMessage_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogMessageRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).LogMessage(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/LogMessage",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).LogMessage(ctx, req.(*LogMessageRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CreateWorkDoneProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkDoneProgressCreateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CreateWorkDoneProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CreateWorkDoneProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CreateWorkDoneProgress(ctx, req.(*WorkDoneProgressCreateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CancelWorkDoneProgress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WorkDoneProgressCancelRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CancelWorkDoneProgress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CancelWorkDoneProgress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CancelWorkDoneProgress(ctx, req.(*WorkDoneProgressCancelRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Telemetry_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(anypb.Any)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Telemetry(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Telemetry",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Telemetry(ctx, req.(*anypb.Any))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_WorkspaceFolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(emptypb.Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).WorkspaceFolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/WorkspaceFolders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).WorkspaceFolders(ctx, req.(*emptypb.Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidChangeWorkspaceFolders_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidChangeWorkspaceFoldersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidChangeWorkspaceFolders(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidChangeWorkspaceFolders",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidChangeWorkspaceFolders(ctx, req.(*DidChangeWorkspaceFoldersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidChangeConfiguration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidChangeConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidChangeConfiguration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidChangeConfiguration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidChangeConfiguration(ctx, req.(*DidChangeConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Configuration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Configuration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Configuration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Configuration(ctx, req.(*ConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidChangeWatchedFiles_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidChangeWatchedFilesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidChangeWatchedFiles(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidChangeWatchedFiles",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidChangeWatchedFiles(ctx, req.(*DidChangeWatchedFilesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_WorkspaceSymbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ConfigurationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).WorkspaceSymbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/WorkspaceSymbols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).WorkspaceSymbols(ctx, req.(*ConfigurationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_ExecuteCommand_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExecuteCommandParams)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).ExecuteCommand(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/ExecuteCommand",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).ExecuteCommand(ctx, req.(*ExecuteCommandParams))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_ApplyEdit_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ApplyWorkspaceEditRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).ApplyEdit(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/ApplyEdit",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).ApplyEdit(ctx, req.(*ApplyWorkspaceEditRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidOpenTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidOpenTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidOpenTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidOpenTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidOpenTextDocument(ctx, req.(*DidOpenTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidChangeTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidChangeTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidChangeTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidChangeTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidChangeTextDocument(ctx, req.(*DidChangeTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_WillSaveTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WillSaveTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).WillSaveTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/WillSaveTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).WillSaveTextDocument(ctx, req.(*WillSaveTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_WillSaveWaitUntilTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WillSaveTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).WillSaveWaitUntilTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/WillSaveWaitUntilTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).WillSaveWaitUntilTextDocument(ctx, req.(*WillSaveTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidSaveTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidSaveTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidSaveTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidSaveTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidSaveTextDocument(ctx, req.(*DidSaveTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DidCloseTextDocument_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DidCloseTextDocumentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DidCloseTextDocument(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DidCloseTextDocument",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DidCloseTextDocument(ctx, req.(*DidCloseTextDocumentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_PublishDiagnostics_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishDiagnosticsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).PublishDiagnostics(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/PublishDiagnostics",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).PublishDiagnostics(ctx, req.(*PublishDiagnosticsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Completion_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Completion(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Completion",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Completion(ctx, req.(*CompletionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CompletionItemResolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompletionItemResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CompletionItemResolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CompletionItemResolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CompletionItemResolve(ctx, req.(*CompletionItemResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Hover_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(HoverRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Hover(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Hover",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Hover(ctx, req.(*HoverRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_SignatureHelp_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SignatureHelpRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).SignatureHelp(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/SignatureHelp",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).SignatureHelp(ctx, req.(*SignatureHelpRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_GotoDeclaration_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DeclarationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).GotoDeclaration(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/GotoDeclaration",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).GotoDeclaration(ctx, req.(*DeclarationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_GotoDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).GotoDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/GotoDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).GotoDefinition(ctx, req.(*DefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_GotoTypeDefinition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TypeDefinitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).GotoTypeDefinition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/GotoTypeDefinition",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).GotoTypeDefinition(ctx, req.(*TypeDefinitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_GotoImplementation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ImplementationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).GotoImplementation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/GotoImplementation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).GotoImplementation(ctx, req.(*ImplementationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_FindReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReferenceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).FindReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/FindReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).FindReferences(ctx, req.(*ReferenceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentHighlights_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentHighlightRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentHighlights(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentHighlights",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentHighlights(ctx, req.(*DocumentHighlightRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentSymbols_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentSymbolRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentSymbols(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentSymbols",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentSymbols(ctx, req.(*DocumentSymbolRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CodeAction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeActionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CodeAction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CodeAction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CodeAction(ctx, req.(*CodeActionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CodeLens_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeLensRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CodeLens(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CodeLens",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CodeLens(ctx, req.(*CodeLensRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CodeLensResolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CodeLensResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CodeLensResolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CodeLensResolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CodeLensResolve(ctx, req.(*CodeLensResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentLink_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentLinkRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentLink(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentLink",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentLink(ctx, req.(*DocumentLinkRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentLinkResolve_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentLinkResolveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentLinkResolve(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentLinkResolve",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentLinkResolve(ctx, req.(*DocumentLinkResolveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentColor_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentColorRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentColor(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentColor",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentColor(ctx, req.(*DocumentColorRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_ColorPresentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ColorPresentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).ColorPresentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/ColorPresentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).ColorPresentation(ctx, req.(*ColorPresentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentFormatting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentFormattingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentFormatting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentFormatting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentFormatting(ctx, req.(*DocumentFormattingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_DocumentRangeFormatting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentRangeFormattingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).DocumentRangeFormatting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/DocumentRangeFormatting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).DocumentRangeFormatting(ctx, req.(*DocumentRangeFormattingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_OnTypeFormatting_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentOnTypeFormattingRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).OnTypeFormatting(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/OnTypeFormatting",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).OnTypeFormatting(ctx, req.(*DocumentOnTypeFormattingRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_Rename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).Rename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/Rename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).Rename(ctx, req.(*RenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_PrepareRename_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PrepareRenameRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).PrepareRename(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/PrepareRename",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).PrepareRename(ctx, req.(*PrepareRenameRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_FoldingRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FoldingRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).FoldingRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/FoldingRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).FoldingRange(ctx, req.(*FoldingRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_SelectionRange_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SelectionRangeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).SelectionRange(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/SelectionRange",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).SelectionRange(ctx, req.(*SelectionRangeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_PrepareCallHierarchy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallHierarchyPrepareRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).PrepareCallHierarchy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/PrepareCallHierarchy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).PrepareCallHierarchy(ctx, req.(*CallHierarchyPrepareRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CallHierarchyIncomingCalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallHierarchyIncomingCallsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CallHierarchyIncomingCalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CallHierarchyIncomingCalls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CallHierarchyIncomingCalls(ctx, req.(*CallHierarchyIncomingCallsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _LanguageServerProtocol_CallHierarchyOutgoingCalls_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallHierarchyOutgoingCallsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(LanguageServerProtocolServer).CallHierarchyOutgoingCalls(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/protocol.rpc.LanguageServerProtocol/CallHierarchyOutgoingCalls",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(LanguageServerProtocolServer).CallHierarchyOutgoingCalls(ctx, req.(*CallHierarchyOutgoingCallsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _LanguageServerProtocol_serviceDesc = grpc.ServiceDesc{
	ServiceName: "protocol.rpc.LanguageServerProtocol",
	HandlerType: (*LanguageServerProtocolServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Cancel",
			Handler:    _LanguageServerProtocol_Cancel_Handler,
		},
		{
			MethodName: "Progress",
			Handler:    _LanguageServerProtocol_Progress_Handler,
		},
		{
			MethodName: "Initialize",
			Handler:    _LanguageServerProtocol_Initialize_Handler,
		},
		{
			MethodName: "Initialized",
			Handler:    _LanguageServerProtocol_Initialized_Handler,
		},
		{
			MethodName: "Shutdown",
			Handler:    _LanguageServerProtocol_Shutdown_Handler,
		},
		{
			MethodName: "Exit",
			Handler:    _LanguageServerProtocol_Exit_Handler,
		},
		{
			MethodName: "LogTrace",
			Handler:    _LanguageServerProtocol_LogTrace_Handler,
		},
		{
			MethodName: "SetTrace",
			Handler:    _LanguageServerProtocol_SetTrace_Handler,
		},
		{
			MethodName: "ShowMessage",
			Handler:    _LanguageServerProtocol_ShowMessage_Handler,
		},
		{
			MethodName: "ShowMessageRequest",
			Handler:    _LanguageServerProtocol_ShowMessageRequest_Handler,
		},
		{
			MethodName: "LogMessage",
			Handler:    _LanguageServerProtocol_LogMessage_Handler,
		},
		{
			MethodName: "CreateWorkDoneProgress",
			Handler:    _LanguageServerProtocol_CreateWorkDoneProgress_Handler,
		},
		{
			MethodName: "CancelWorkDoneProgress",
			Handler:    _LanguageServerProtocol_CancelWorkDoneProgress_Handler,
		},
		{
			MethodName: "Telemetry",
			Handler:    _LanguageServerProtocol_Telemetry_Handler,
		},
		{
			MethodName: "WorkspaceFolders",
			Handler:    _LanguageServerProtocol_WorkspaceFolders_Handler,
		},
		{
			MethodName: "DidChangeWorkspaceFolders",
			Handler:    _LanguageServerProtocol_DidChangeWorkspaceFolders_Handler,
		},
		{
			MethodName: "DidChangeConfiguration",
			Handler:    _LanguageServerProtocol_DidChangeConfiguration_Handler,
		},
		{
			MethodName: "Configuration",
			Handler:    _LanguageServerProtocol_Configuration_Handler,
		},
		{
			MethodName: "DidChangeWatchedFiles",
			Handler:    _LanguageServerProtocol_DidChangeWatchedFiles_Handler,
		},
		{
			MethodName: "WorkspaceSymbols",
			Handler:    _LanguageServerProtocol_WorkspaceSymbols_Handler,
		},
		{
			MethodName: "ExecuteCommand",
			Handler:    _LanguageServerProtocol_ExecuteCommand_Handler,
		},
		{
			MethodName: "ApplyEdit",
			Handler:    _LanguageServerProtocol_ApplyEdit_Handler,
		},
		{
			MethodName: "DidOpenTextDocument",
			Handler:    _LanguageServerProtocol_DidOpenTextDocument_Handler,
		},
		{
			MethodName: "DidChangeTextDocument",
			Handler:    _LanguageServerProtocol_DidChangeTextDocument_Handler,
		},
		{
			MethodName: "WillSaveTextDocument",
			Handler:    _LanguageServerProtocol_WillSaveTextDocument_Handler,
		},
		{
			MethodName: "WillSaveWaitUntilTextDocument",
			Handler:    _LanguageServerProtocol_WillSaveWaitUntilTextDocument_Handler,
		},
		{
			MethodName: "DidSaveTextDocument",
			Handler:    _LanguageServerProtocol_DidSaveTextDocument_Handler,
		},
		{
			MethodName: "DidCloseTextDocument",
			Handler:    _LanguageServerProtocol_DidCloseTextDocument_Handler,
		},
		{
			MethodName: "PublishDiagnostics",
			Handler:    _LanguageServerProtocol_PublishDiagnostics_Handler,
		},
		{
			MethodName: "Completion",
			Handler:    _LanguageServerProtocol_Completion_Handler,
		},
		{
			MethodName: "CompletionItemResolve",
			Handler:    _LanguageServerProtocol_CompletionItemResolve_Handler,
		},
		{
			MethodName: "Hover",
			Handler:    _LanguageServerProtocol_Hover_Handler,
		},
		{
			MethodName: "SignatureHelp",
			Handler:    _LanguageServerProtocol_SignatureHelp_Handler,
		},
		{
			MethodName: "GotoDeclaration",
			Handler:    _LanguageServerProtocol_GotoDeclaration_Handler,
		},
		{
			MethodName: "GotoDefinition",
			Handler:    _LanguageServerProtocol_GotoDefinition_Handler,
		},
		{
			MethodName: "GotoTypeDefinition",
			Handler:    _LanguageServerProtocol_GotoTypeDefinition_Handler,
		},
		{
			MethodName: "GotoImplementation",
			Handler:    _LanguageServerProtocol_GotoImplementation_Handler,
		},
		{
			MethodName: "FindReferences",
			Handler:    _LanguageServerProtocol_FindReferences_Handler,
		},
		{
			MethodName: "DocumentHighlights",
			Handler:    _LanguageServerProtocol_DocumentHighlights_Handler,
		},
		{
			MethodName: "DocumentSymbols",
			Handler:    _LanguageServerProtocol_DocumentSymbols_Handler,
		},
		{
			MethodName: "CodeAction",
			Handler:    _LanguageServerProtocol_CodeAction_Handler,
		},
		{
			MethodName: "CodeLens",
			Handler:    _LanguageServerProtocol_CodeLens_Handler,
		},
		{
			MethodName: "CodeLensResolve",
			Handler:    _LanguageServerProtocol_CodeLensResolve_Handler,
		},
		{
			MethodName: "DocumentLink",
			Handler:    _LanguageServerProtocol_DocumentLink_Handler,
		},
		{
			MethodName: "DocumentLinkResolve",
			Handler:    _LanguageServerProtocol_DocumentLinkResolve_Handler,
		},
		{
			MethodName: "DocumentColor",
			Handler:    _LanguageServerProtocol_DocumentColor_Handler,
		},
		{
			MethodName: "ColorPresentation",
			Handler:    _LanguageServerProtocol_ColorPresentation_Handler,
		},
		{
			MethodName: "DocumentFormatting",
			Handler:    _LanguageServerProtocol_DocumentFormatting_Handler,
		},
		{
			MethodName: "DocumentRangeFormatting",
			Handler:    _LanguageServerProtocol_DocumentRangeFormatting_Handler,
		},
		{
			MethodName: "OnTypeFormatting",
			Handler:    _LanguageServerProtocol_OnTypeFormatting_Handler,
		},
		{
			MethodName: "Rename",
			Handler:    _LanguageServerProtocol_Rename_Handler,
		},
		{
			MethodName: "PrepareRename",
			Handler:    _LanguageServerProtocol_PrepareRename_Handler,
		},
		{
			MethodName: "FoldingRange",
			Handler:    _LanguageServerProtocol_FoldingRange_Handler,
		},
		{
			MethodName: "SelectionRange",
			Handler:    _LanguageServerProtocol_SelectionRange_Handler,
		},
		{
			MethodName: "PrepareCallHierarchy",
			Handler:    _LanguageServerProtocol_PrepareCallHierarchy_Handler,
		},
		{
			MethodName: "CallHierarchyIncomingCalls",
			Handler:    _LanguageServerProtocol_CallHierarchyIncomingCalls_Handler,
		},
		{
			MethodName: "CallHierarchyOutgoingCalls",
			Handler:    _LanguageServerProtocol_CallHierarchyOutgoingCalls_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "protocol/rpc/rpc.proto",
}
